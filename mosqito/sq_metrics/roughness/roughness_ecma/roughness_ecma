from numpy import(
    arange,
    int32,
    abs,
    power,
    zeros,
    empty,
    sum,
    array,
    clip,
    exp,
    mean,
    median,
    where,
    diff,
    sign,
    argmax,
    argmin,
    flip,
    argsort,
    ones,
    delete,
    exp,
    dot,
    round,
    squeeze,

)
from numpy.fft import fft
from numpy.linalg import inv
from scipy.signal import (hilbert, resample, find_peaks)
from scipy.signal.windows import hann


# Project Imports
from mosqito.sq_metrics.loudness.loudness_ecma._rectified_band_pass_signals import _rectified_band_pass_signals
from mosqito.sq_metrics.loudness.loudness_ecma._nonlinearity import _nonlinearity
from mosqito.sq_metrics.loudness.loudness_ecma._auditory_filters_centre_freq import _auditory_filters_centre_freq

# Data import
# Threshold in quiet
from mosqito.sq_metrics import loudness_ecma

from mosqito.utils import load

from peak_correction import rho, r_max, Q2_high, Q2_low


def roughness_ecma(signal):
    """Calculation of the roughness according to ECMA-418-2 section 7

    Parameters
    ----------
    signal: numpy.array
        time signal values in 'Pa'. The sampling frequency of the signal must be 48000 Hz.

    Returns
    -------
    n_specific: list of numpy.array
        Specific Loudness [sone_HMS per Bark]. Each of the 53 element of the list corresponds to the time-dependant
        specific loudness for a given bark band. Can be a ragged array if a different sb/sh are used for each band.
    bark_axis: numpy.array
        Bark axis
    """
    # Sampling frequency
    fs = 48000
    N_samples = len(signal)
    CBF = 53
    center_freq = _auditory_filters_centre_freq()

    # Hop size and block size for specific loudness calculation (7.1.1)
    sb=16384
    sh=4096
    N_specific, bark_axis = loudness_ecma(signal, sb, sh)
    N_specific = array(N_specific)
    # ! ces valeurs sont déjà calculées dans la loudness
    block_array_rect = array(_rectified_band_pass_signals(signal, sb, sh))
    L = block_array_rect.shape[1]
    # ENVELOPPE CALCULATION AND DOWNSAMPLING (7.1.2)
    envelopes = abs(block_array_rect + 1j * hilbert(block_array_rect))

    # Downsampling to 1500 Hz
    # New block and hop sizes
    sbb = 512
    shh = 128
    envelopes = resample(envelopes, sbb, axis=2)
    ########## BOUCLE SUR LES TIME BLOCKS l (voir nouveau fichier)


    # CALCULATION OF SCALED POWER SPECTRUM (7.1.3)
    spectrum = zeros((CBF,L,sbb//2))
    N_specific_max = array(N_specific).max(axis=0)
    phi_e = sum(power(envelopes * hann(sbb),2), axis=2)
    den = N_specific_max * phi_e
    # pk den nul ?

    # Hann window is precisely defined in the standard !!
    dft = power(abs(fft((envelopes * hann(sbb)),n=sbb//2, axis=2)),2)
    
    for z in range(envelopes.shape[0]): # for each CBF
        for l in range(envelopes.shape[1]): # for each time block
            if den[z,l]!=0:
                spectrum[z,l,:] = power(N_specific[z,l],2) / den[z,l] * dft[z,l,:]

    # NOISE REDUCTION OF THE ENVELOPES (7.1.4)

    # Averaging with neighbouring bands
    av_spectrum = empty((spectrum.shape))
    av_spectrum[0,:] = (spectrum[0,:]+spectrum[1,:])/2
    av_spectrum[-1,:] = (spectrum[-1,:]+spectrum[-2,:])/2
    av_spectrum[1:-1,:] = (spectrum[:-2,:]+spectrum[1:-1,:]+spectrum[2:,:])/3

    S = av_spectrum.sum(axis=0)
    SS = median(S, axis=1)

    # Weighting 
    wfw = zeros(S.shape)
    wf = zeros(S.shape)
    for k in range(sbb//2): # for each time block
        wfw[:,k] = 0.0856 * S[:,k]/(SS+10e-10) * clip(0.1891*exp(0.0120*k),0,1)

    idt = 0.05 * wfw.max(axis=1)
    Phi_E = zeros(av_spectrum.shape)
    amplitude = zeros((S.shape))

    for l in range(S.shape[0]):       
        idt = where(wfw[l,:]>0.05 * wfw[l,:].max())
        wf[l,idt] = clip(wfw[l,idt]-0.1407,0,1)
        
        
        for z in range(CBF):
            Phi_E[z,l,:] = av_spectrum[z,l,:] * wf[l,:]
            fmax = 72.6937*(1-1.1739*exp(-5.4583*center_freq[z]/1000)) # center_freq = fréquence centrale de la bande z (eq 86 clause 7.1.5.2)
            rmax = r_max(center_freq[z])
            q2_high = Q2_high(center_freq[z])
            q2_low = Q2_low(center_freq[z])
        # SPECTRAL WEIGHTING (7.1.5)
        for k in range(sbb//2):
            # Peak picking
            maxima = find_peaks(Phi_E[:,l,k])[0]
            
    
        # create a function "compute_prominence(Phi_E, maxima)"
            
            if len(maxima) > 0:
                
                if len(maxima) == 1:
                    print('only 1 maximum')
                    # since there is only one peak, the limits of the interval where to search for the maximum valley are the signal's ones
                    # left side
                    left_limit = 0 
                    left_valley_idx = maxima[0] - argmax(flip(Phi_E[maxima[0],l,k]-Phi_E[left_limit:maxima[0],l,k]))
                    left_valley =  Phi_E[maxima[0],l,k] - Phi_E[left_valley_idx,l,k]

                    # right side
                    right_limit = CBF
                    right_valley_idx = argmax(Phi_E[maxima[0],l,k]-Phi_E[maxima[0]:right_limit,l,k])
                    right_valley = Phi_E[maxima[0],l,k] - Phi_E[right_valley_idx,l,k]

                    if left_valley > right_valley:
                        prominence = [left_valley]
                        prominence_idx = maxima
                    else:
                        prominence = [right_valley]
                        prominence_idx = maxima

                else:
                    print('multiple maxima')
                    prominence = zeros(len(maxima))
                    
                    for i in range(len(maxima)):
                        
                        peak_level = Phi_E[maxima[i],l,k]
                        crossing = False
                        offset = 1
                        # left side
                        while crossing == False: 
                            if (i == 0) or ((i-offset)<0): # first peak or no more peak at the left
                                crossing = True # left limit of the signal
                                left_limit = 0
                            elif Phi_E[maxima[i-offset],l,k] > peak_level:
                                crossing = True
                                left_limit = maxima[i-offset]
                            else:
                                offset += 1

                        

                        left_valley_idx = maxima[i] - 1 - argmax(flip(Phi_E[maxima[i],l,k]-Phi_E[left_limit:maxima[i],l,k]))
                        left_valley =  peak_level - Phi_E[left_valley_idx,l,k]

                        # right side
                        crossing = False
                        offset = 1
                        while crossing == False:
                            if (i == len(maxima)) or ((i+offset)>len(maxima)-1): # last peak or no more peak at the right
                                crossing = True # right limit of the signal
                                right_limit = CBF
                            elif Phi_E[maxima[i+offset],l,k] > peak_level:
                                crossing = True
                                right_limit = maxima[i+offset]
                            else:
                                offset += 1

                        right_valley_idx = maxima[i] + argmax(peak_level-Phi_E[maxima[i]:right_limit,l,k])
                        right_valley = peak_level - Phi_E[right_valley_idx,l,k]

                        if left_valley > right_valley:
                            prominence[i] = left_valley
                        else:
                            prominence[i] = right_valley
                               


                    # garder les 10 plus grands
                    if len(maxima)>10:
                        sort_idx = argsort(prominence)
                        prominence = prominence[sort_idx[-10:]]
                        prominence_idx = maxima[sort_idx[-10:]]
                    else:
                        prominence_idx = maxima
                    prominence_idx = prominence_idx.astype(int32)

                     #TODO: supprimer la boucle
                    for peak in arange(len(prominence)):
                        print(peak)
                        if Phi_E[prominence_idx[peak],l,k]<=0.05*max(Phi_E[prominence_idx,l,k]):
                            prominence = delete(prominence, peak)
                            prominence_idx = delete(prominence_idx, peak)

                amp = zeros(len(prominence))
                mod_rate = zeros(len(prominence))

                for i in range(len(prominence)):
                
                    K = array([[prominence_idx[i]**2, prominence_idx[i]-1, 1],[prominence_idx[i]**2, prominence_idx[i], 1],[(prominence_idx[i]+1)**2, prominence_idx[i]+1, 1]])
                    Phi = array([Phi_E[prominence_idx[i],l,k-1], Phi_E[prominence_idx[i],l,k], Phi_E[prominence_idx[i],l,k+1]])
                    C = dot(inv(K), Phi)

                    delta_f = 1500/512
                    F = -C[1]/(2*C[0])*delta_f
                    mod_rate[i] = F + rho(F, delta_f) # modulation rate

                    

                    # Weighting of high modulation rates
                    A = Phi_E[prominence_idx[i],l,k-1] + Phi_E[prominence_idx[i],l,k] + Phi_E[prominence_idx[i],l,k+1] # amplitude

                    if mod_rate[i]<fmax:
                        amp[i] = A * rmax
                    else:
                        G = 1/((1+((mod_rate[i]/fmax-fmax/mod_rate[i])*1.2822)**2)**q2_high)
                        amp[i] = G * A * rmax

                # Estimation of fundamental modulation rate (7.1.5.3) (ne dépend pas de l et z)
                complex_energy = zeros((len(prominence)))
                harmonic_complex = zeros((len(prominence)), dtype=object)
                for i0 in range(len(prominence)):
                    mod_rate_temp = mod_rate[i0:]
                    R = round(mod_rate_temp/mod_rate[i0])
                    
                    # check for duplicates in R
                    duplicates = set()
                    duplicates = [x for x in R if x in duplicates or duplicates.add(x)]

                    if len(duplicates)> 0 :
                        delete_list = []
                        for dup in duplicates:                                
                            dup_idx = where((R==dup))[0]
                            keep = argmin(abs(mod_rate_temp[dup_idx]/(array(R)[dup_idx]*mod_rate[i0])-1))
                            delete_list.append([dup_idx[x] for x in range(len(dup_idx)) if x!=keep])
                        R = delete(R, squeeze(delete_list))
                        mod_rate_temp = delete(mod_rate_temp, squeeze(delete_list))
                        

                        
                        
                    
                    harmonic_complex[i0] = where((abs(mod_rate_temp/(R*mod_rate[i0])-1) < 0.04))[0]
                    complex_energy[i0] = sum(amp[harmonic_complex[i0]])
                
                import pdb; pdb.set_trace()
                
                    
                        
                i_max = prominence_idx[argmax(complex_energy)]
                h_complex_max = harmonic_complex[argmax(complex_energy)]

                w = 1 + 0.1 * abs(sum(mod_rate[h_complex_max]*amp[h_complex_max])/sum(amp[h_complex_max])-mod_rate[argmax(amp[h_complex_max])])**0.749

                Amp = amp[h_complex_max] * w

                # Weighting of low modulation rates
                if mod_rate[i_max] < fmax:
                    G = 1/((1+((mod_rate[i]/fmax-fmax/mod_rate[i])*0.7066)**2)**q2_low)
                    amplitude[l,z] = sum(G * Amp)
                else:
                    amplitude[l,z]= sum(Amp)

                if A<0.074376:
                    amplitude[l,z] = 0

            else:
                amplitude[l,z] = 0

    # ENTROPY WEIGHTING (OPTIONAL) (7.1.6)


    # CALCULATION OF TIME DEPENDENT SPECIFIC ROUGHNESS (7.1.7)

    

    # CALCULATION OF REPRESENTATIVE VALUES (7.1.8)

    # CALCULATION OF ROUGHNESS FOR BINAURAL SIGNALS


    return envelopes


signal, fs = load(r"C:\Users\LAP16\Documents\MoSQITooo\validations\sq_metrics\roughness_dw\input\Test_signal_fc1000_fmod70.wav", wav_calib=0.02)
signal, fs = load(r"C:\Users\LAP16\Desktop\loudness scale\marteau_piqueur.wav", wav_calib=0.2)
import matplotlib.pyplot as plt

envelopes = roughness_ecma(signal[:int(len(signal)/2)])