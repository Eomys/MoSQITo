from numpy import(
    abs,
    append,
    power,
    zeros,
    empty,
    sum,
    array,
    clip,
    exp,
    median,
    where,
    argmax,
    argmin,
    argsort,
    delete,
    exp,
    dot,
    round,
    squeeze,
    sqrt,
    tanh,
    sign,
    diff,
    percentile,
    dot,
    int32,
    transpose,
    mean,
)
from numpy.fft import fft
from numpy.linalg import inv
from scipy.signal import (hilbert, resample, find_peaks)
from scipy.signal.windows import hann


# Project Imports
from mosqito.sq_metrics.loudness.loudness_ecma._rectified_band_pass_signals import _rectified_band_pass_signals
from mosqito.sq_metrics.loudness.loudness_ecma._auditory_filters_centre_freq import _auditory_filters_centre_freq

# Data import
# Threshold in quiet
from mosqito.sq_metrics import loudness_ecma

from mosqito.utils import load

from _weighting import rho, f_max, r_max, Q2_high, Q2_low, _high_mod_rate_weighting, _low_mod_rate_weighting
from _comp_prominence import _comp_prominence


def roughness_ecma(signal):
    """Calculation of the roughness according to ECMA-418-2 section 7

    Parameters
    ----------
    signal: numpy.array
        time signal values in 'Pa'. The sampling frequency of the signal must be 48000 Hz.

    Returns
    -------
    n_specific: list of numpy.array
        Specific Loudness [sone_HMS per Bark]. Each of the 53 element of the list corresponds to the time-dependant
        specific loudness for a given bark band. Can be a ragged array if a different sb/sh are used for each band.
    bark_axis: numpy.array
        Bark axis
    """
    # Sampling frequency
    fs = 48000
    N_samples = len(signal)
    duration = N_samples / fs
    CBF = 53
    center_freq = _auditory_filters_centre_freq()

    # Hop size and block size for specific loudness calculation (7.1.1)
    sb=16384
    sh=4096
    N_specific, _ = loudness_ecma(signal, sb, sh)
    N_specific = array(transpose(N_specific))
    # ! ces valeurs sont déjà calculées dans la loudness
    block_array_rect = array(_rectified_band_pass_signals(signal, sb, sh))
    L = block_array_rect.shape[1]
    # ENVELOPPE CALCULATION AND DOWNSAMPLING (7.1.2)
    envelopes = transpose(abs(block_array_rect + 1j * hilbert(block_array_rect)), (1,0,2))  # transpose is used to stick to the standard index order l,z,k
    N_pts = envelopes.shape[2]

    # Downsampling to 1500 Hz
    # New block and hop sizes
    sbb = 512
    K = sbb//2
    shh = 128
    envelopes = resample(envelopes, sbb, axis=2)

    # CALCULATION OF SCALED POWER SPECTRUM (7.1.3)
    spectrum = zeros((L,CBF,K))
    N_specific_max = array(N_specific).max(axis=1)
    phi_e = sum(power(envelopes * hann(sbb),2), axis=2)
    den = transpose(N_specific_max * transpose(phi_e))
    # pk den nul ?

    # Hann window is precisely defined in the standard !!
    dft = power(abs(fft((envelopes * hann(sbb)),n=K, axis=2)),2)
    spectrum[where((den!=0))[0],where((den!=0))[1],:] = transpose(power(N_specific[where((den!=0))],2) / den[where((den!=0))] * transpose(dft[where((den!=0))[0],where((den!=0))[1],:]))

    # NOISE REDUCTION OF THE ENVELOPES (7.1.4)
    # Averaging with neighbouring bands
    av_spectrum = empty((L,CBF,K))
    av_spectrum[:,0] = (spectrum[:,0]+spectrum[:,1])/2
    av_spectrum[:,-1] = (spectrum[:,-1]+spectrum[:,-2])/2
    av_spectrum[:,1:-1] = (spectrum[:,:-2]+spectrum[:,1:-1]+spectrum[:,2:])/3

    S = av_spectrum.sum(axis=1)
    SS = median(S, axis=1)

    # Weighting 
    w_wave = zeros((L,K))
    noise_suppression_weighting = zeros((L,K))
    for k in range(K): 
        w_wave[:,k] = 0.0856 * S[:,k]/(SS+10e-10) * clip(0.1891*exp(0.0120*k),0,1)
    idt = 0.05 * w_wave.max(axis=1)
    Phi_E = zeros((L,CBF,K))
    amplitude = zeros((L,CBF))

    for l in range(L):       
        idt = where((w_wave[l,:]>0.05 * w_wave[l,:].max()))[0]
        noise_suppression_weighting[l,idt] = clip(w_wave[l,idt]-0.1407,0,1)
        
        for z in range(CBF):
            Phi_E[l,z,:] = av_spectrum[l,z,:] * noise_suppression_weighting[l,:]
            # Critical bands characteristics for the weightings to come
            fmax = f_max(center_freq[z]) # center_freq = fréquence centrale de la bande z (eq 86 clause 7.1.5.2)
            rmax = r_max(center_freq[z])
            q2_high = Q2_high(center_freq[z])
            q2_low = Q2_low(center_freq[z])

            # SPECTRAL WEIGHTING (7.1.5)
            # Peak picking
            maxima = find_peaks(Phi_E[l,z,:])[0]
            if len(maxima) == 0:
                amplitude[l,z] = 0
                prominence = []
                prominence_idx = []
            elif len(maxima) > 0:
                if len(maxima) == 1:
                    prominence = _comp_prominence(Phi_E[l,z,:], maxima, 0)
                    prominence_idx = maxima
                elif len(maxima) > 0:
                    prominence = zeros(len(maxima))
                    # For each peak
                    for i in range(len(maxima)):
                        prominence[i] = _comp_prominence(Phi_E[l,z,:], maxima, i)
                    # Keep 10 maximum values
                    if len(maxima) > 10:
                        sort_idx = argsort(prominence)
                        prominence = prominence[sort_idx[-10:]]
                        prominence_idx = maxima[sort_idx[-10:]]
                    else:
                        prominence_idx = maxima
                idx = where((Phi_E[l,z,prominence_idx]) <= 0.05*max(Phi_E[l,z,prominence_idx]))[0]
                prominence = delete(prominence, idx)
                prominence_idx = delete(prominence_idx, idx)

                N_peak = len(prominence)
                amp = zeros(N_peak)
                mod_rate = zeros(N_peak)

                # For each prominent peak identified
                for i in range(N_peak):
                    kpi = prominence_idx[i]
                    # Refinement step
                    Km = array([[kpi**2, kpi-1, 1],[kpi**2, kpi, 1],[(kpi+1)**2, kpi+1, 1]])
                    
                    if kpi == 0:
                        Phi = array([0, Phi_E[l,z,kpi], Phi_E[l,z,kpi+1]])
                        amp_temp = Phi_E[l,z,kpi] + Phi_E[l,z,kpi+1] 
                    elif k == K-1:
                        Phi = array([Phi_E[l,z,kpi-1], Phi_E[l,z,kpi], 0])
                        amp_temp = Phi_E[l,z,kpi-1] + Phi_E[l,z,kpi]
                    else:
                        Phi = array([Phi_E[l,z,kpi-1], Phi_E[l,z,kpi], Phi_E[l,z,kpi+1]])
                        amp_temp = Phi_E[l,z,kpi-1] + Phi_E[l,z,kpi] + Phi_E[l,z,kpi+1] 

                    C = dot(inv(Km), Phi)
                    delta_f = 1500/512
                    F = -C[1]/(2*C[0])*delta_f
                    mod_rate[i] = F + rho(F, delta_f) # modulation rate

                    # Weighting of high modulation rates
                    amp[i] = _high_mod_rate_weighting(mod_rate[i], amp_temp, fmax, rmax, q2_high)

                # Estimation of fundamental modulation rate (7.1.5.3) (ne dépend pas de l et z)
                complex_energy = zeros((N_peak))
                harmonic_complex = zeros((N_peak), dtype=object)
                for i0 in range(N_peak):
                    mod_rate_temp = mod_rate[i0:]
                    R = round(mod_rate_temp/mod_rate[i0])
                    
                    # check for duplicates in R
                    if len(R)>1:
                        duplicates = set()
                        duplicates = [x for x in R if x in duplicates or duplicates.add(x)]
                    else:
                        duplicates = []
                    if len(duplicates)> 0 :
                        delete_list = array([])
                        for dup in duplicates:                                
                            dup_idx = where((R==dup))[0]
                            keep = argmin(abs(mod_rate_temp[dup_idx]/(array(R)[dup_idx]*mod_rate[i0])-1))
                            delete_list = append(delete_list, [dup_idx[x] for x in range(len(dup_idx)) if x!=keep])
                        R = delete(R, squeeze(delete_list).astype(int32))
                        mod_rate_temp = delete(mod_rate_temp, squeeze(delete_list).astype(int32))   
                        
                        
                    harmonic_complex[i0] = where((abs(mod_rate_temp/(R*mod_rate[i0])-1) < 0.04))[0]
                    complex_energy[i0] = sum(amp[harmonic_complex[i0]])
                        
                i_max = argmax(complex_energy)
                h_complex_max = harmonic_complex[argmax(complex_energy)]

                w = 1 + 0.1 * abs(sum(mod_rate[h_complex_max]*amp[h_complex_max])/sum(amp[h_complex_max])-mod_rate[argmax(amp[h_complex_max])])**0.749
                amp_temp = amp[h_complex_max] * w
                
                # Weighting of low modulation rates
                amplitude[l,z] = _low_mod_rate_weighting(mod_rate[i_max], amp_temp, fmax, q2_low)

                if amplitude[l,z]<0.074376:
                    amplitude[l,z] = 0

    
    # ENTROPY WEIGHTING (OPTIONAL) (7.1.6)

    # CALCULATION OF TIME DEPENDENT SPECIFIC ROUGHNESS (7.1.7)
    # amplitude_50 = CubicHermiteSpline(amplitude, linspace(0,256),)
    
    N50 = int(N_pts/48000*50)
    amplitude_50 = resample(amplitude, N50, axis=0)
    amplitude_50 = amplitude_50[:int(duration*50),:] # delete zero-padding
    
    idx = where((amplitude_50>=0))
    R_est = zeros((N50, CBF))
    R_est[idx] = amplitude_50[idx]

    R_lin_mean = sum(R_est, axis=1)/53
    R_sq_mean = sqrt(sum(R_est, axis=1)**2/53)

    B = zeros((N50))
    B[R_lin_mean!=0] = R_sq_mean[R_lin_mean!=0] / R_lin_mean[R_lin_mean!=0]
    E = 0.95555 * (tanh(1.6407*(B-2.5804))+1)*0.5+0.58449

    R_time_spec_temp = transpose(0.0180909 * power(transpose(R_est),E))

    slope = sign(diff(R_time_spec_temp, axis=0))
    tau = zeros((N50-1,CBF))
    tau[where((slope>=0))] = 0.0625
    tau[where((slope<0))] = 0.5000
    R_time_spec = zeros((N50, CBF))
    R_time_spec[0,:] = R_time_spec_temp[0,:]
    R_time_spec[1:,:] = R_time_spec_temp[1:,:]*(1-exp(-1/(50*tau)))  + R_time_spec_temp[0:-1,:]*exp(-1/(50*tau))

    # CALCULATION OF REPRESENTATIVE VALUES (7.1.8)
    # CBF dependent value
    R_spec = mean(R_time_spec[15:,:], axis=0)
    # time_dependent value
    R_time = 0.5 * sum(R_time_spec, axis=1)
    # single value
    R = percentile(R_time, 90)
    
    return R_spec, R_time, R


signal, fs = load(r"C:\Users\LAP16\Documents\MoSQITooo\validations\sq_metrics\roughness_dw\input\Test_signal_fc1000_fmod70.wav",)
#signal, fs = load(r"C:\Users\LAP16\Desktop\loudness scale\marteau_piqueur.wav", wav_calib=0.8)
import matplotlib.pyplot as plt

R_spec, R_time, R = roughness_ecma(signal[:int(len(signal)/2)])


import matplotlib.pyplot as plt
from numpy import linspace

plt.step(linspace(0,53,53), R_spec)
plt.title('Specific roughness, global value = ')

plt.show(block=True)
